#encoding: utf-8

require 'find'

module ADONIS
module EXPLOIT


class ModuleNode
    attr_accessor :base, :floder_name, :father_node_list, :children_node_list, :active
   
    # 节点名字
    def initialize base, floder_name = nil, active = true
	@base = base
	@floder_name = floder_name
	@active = active
	@children_node_list = []
	@father_node_list = []
	return self
    end

end

# 渗透树，跟节点
ModuleRoot = ModuleNode.new ::ADONIS::EXPLOIT::RootBase.new.init

class ModuleHelper

    def self.create_node_by_base base, floder_name = nil, active = true
	node = ::ADONIS::EXPLOIT::ModuleNode.new base, floder_name, active
	#p "初始化node: #{node.node_name}"
	insert_node node
    end

    def self.insert_node node
	r = false
        tmp_mount_list = []
	node.base.father_node_name_list.each do |father_node_name|
		father_node = find_node_by_name father_node_name
		if father_node.blank?
			@@umount_node_list.push node unless @@umount_node_list.map{|x| x.base.name}.include?(node.base.name)
			next
		end
                tmp_mount_list.push father_node_name
		# 如果未添加则添加
		node.father_node_list.push father_node unless node.father_node_list.map{|n| n.base.name}.include?(father_node.base.name)
		father_node.children_node_list.push node unless father_node.children_node_list.map{|n| n.base.name}.include?(node.base.name)
		r = true
	end
        node.base.father_node_name_list = node.base.father_node_name_list - tmp_mount_list
	return r
    end

    def self.create_module_tree
	# 初始化一些类变量，供之后查找
	@@all_module_id_list = []
	@@umount_node_list = []

	# 生成第二层跟节点
	::ADONIS::MODEL::Host.port_key_list.each do |port_string|
		port_list = port_string.split('_')
		node_base = ::ADONIS::EXPLOIT::MODULE::CheckPort.new port_list[0], port_list[1]
		create_node_by_base node_base
	end

	# 生成所有渗透节点
	load_and_create_exploit_node

    end

    # 加载所有渗透叶子节点
    def self.load_and_create_exploit_node
        Find.find(File.join(::ADONIS::BaseDir, "modules")).each do |x|
                load x if x =~ /^*.rb$/
        end

	::ADONIS::MODULE.local_constants.each do |c|
		base_class_list = []

		bc = ::ADONIS::MODULE.class_eval(c.to_s).new.init
		base_class_list.push bc

		# 生成路由节点的子节点
		if bc.type == 'route'
			bc.route_name_list.each do |route_name|
				base_class_list << ::ADONIS::EXPLOIT::Base.new.route_children_init(bc, route_name)
			end
		end

		base_class_list.each do |base_class|
			# 检测module base id 是否合法
			if @@all_module_id_list.include?(base_class.id) and not base_class.muti_id
				p base_class.name
				next
			end
			@@all_module_id_list.push base_class.id unless @@all_module_id_list.include?(base_class.id)
		
			# 检测此 id 是否激活
			active_id_list = get_active_module_id_list
			if active_id_list.include?(base_class.id)
				create_node_by_base base_class, nil, true
			else
				create_node_by_base base_class, nil, false
			end
		end
	end

	# 轮询挂载未挂载的节点，直到全部不成功为止
	r = true
	while r
		r = recheck_umount_node
	end
    end
	
    # 重复检测未挂载的节点
    def self.recheck_umount_node
	r = false
	@@umount_node_list.each do |node|
		r = true if insert_node node
	end
	@@umount_node_list.delete_if{|x| x.base.father_node_name_list.size == 0}
	return r
    end

    def self.find_node_by_floder_name floder_name, root_node = nil
	nil
    end

    # 通过 base name 查找 node
    def self.find_node_by_name name, node = ::ADONIS::EXPLOIT::ModuleRoot
	return node if node.base.name == name
	return nil if node.children_node_list.size == 0
	node.children_node_list.each do |n|
		r =  find_node_by_name(name, n)
		return r if r != nil
	end
	return nil
    end

    # 通过 base id 查找 node
    def self.find_node_by_id id, node = ::ADONIS::EXPLOIT::ModuleRoot
	return node if node.base.id == id
	return nil if node.children_node_list.size == 0
	node.children_node_list.each do |n|
		r =  find_node_by_id(id, n)
		return r if r != nil
	end
	return nil
    end

    def self.print_node_tree verbose = false
        columns = ["id", "name", "father_node_name", "active", "type", "children_node"]
        show_table = Rex::Ui::Text::Table.new(
            'Header' => "EXPLOIT模块",
            'Ident' => 1,
            'Columns' => columns,
        )
	#__print_node_tree show_table, ::ADONIS::EXPLOIT::ModuleRoot, verbose
	all_node.each do |node|
        	show_table.add_row [node.base.id, node.base.name, node.father_node_list.map{|x| x.base.name}.join(','), 
			node.active.to_s, node.base.type, node.children_node_list.map{|x| x.base.name}.join(',')]
	end
 
        show_table.print
    end

    def self.all_node root_node = ::ADONIS::EXPLOIT::ModuleRoot
	tmp_list = []
	__get_all_node_list tmp_list, root_node
	return tmp_list
    end

    def self.__get_all_node_list tmp_list, root_node
	root_node.children_node_list.each do |n|
		__get_all_node_list(tmp_list, n)
	end
	tmp_list.push root_node unless tmp_list.include?(root_node)
    end

    def self.get_module_list_by_id_str str
        module_list = []
        str.split(',').each do |s|
            return @@all_module_id_list if s == "all"
            module_list << s.to_i if @@all_module_id_list.include?(s.to_i)
        end
        return module_list
    end

    def self.active_module module_id
        unless module_id.is_a?(Array)
            module_id = [].push module_id
        end

        module_list = get_active_module_id_list
        module_id.each do |mid|
            mid = mid.to_i
            module_list.push mid if module_list.is_a?(Array) and not module_list.include?(mid)
        end
        ::ADONIS::COMMON::Queue.set "exploit_module_list", module_list.to_json
    end

    def self.inactive_module module_id
        unless module_id.is_a?(Array)
            module_id = [].push module_id
        end

        module_list = get_active_module_id_list
        module_id.each do |mid|
            mid = mid.to_i
            module_list.delete mid if module_list.is_a?(Array) and module_list.include?(mid)
        end

        ::ADONIS::COMMON::Queue.set "exploit_module_list", module_list.to_json
    end

    def self.get_active_module_id_list
        r = ::ADONIS::COMMON::Queue.get "exploit_module_list"
        r.blank? ? Array.new : JSON.parse(r)
    end

   
end

end
end
