#encoding: utf-8

require 'thread'

module ADONIS
module EXPLOIT

class Base

    attr_accessor :id, :name, :score, :father_node_name_list, :desc

    CHECK_TYPE = 1
    EXPLOIT_TYPE = 2
    ROUTE_TYPE = 3
    INFO_TYPE = 4

    # id, 名称，父节点名称，描述
    def base_init(id, name, score, father_node_name_list, node_type, desc)
        @id = id
        @name = name
        @score = score
	@node_type = node_type
	if father_node_name_list.is_a?(String)
        	@father_node_name_list = [father_node_name_list]
	elsif father_node_name_list.is_a?(Array)
        	@father_node_name_list = father_node_name_list
	else
        	@father_node_name_list = father_node_name_list
	end
        @desc = desc

        return self
    end

    # 初始化 check type 的 node
    def check_init(id, name, father_node_name, desc = nil)
	base_init(id, name, 0, father_node_name, CHECK_TYPE, desc)
    end

    # 初始化 exploit type 的 node
    def exploit_init(id, name, father_node_name, score = 0, desc = nil)
	base_init(id, name, score, father_node_name, EXPLOIT_TYPE, desc)
    end

    # 初始化 route type 的 node
    def route_init(id, name, father_node_name, route_name_list, desc = nil)
	@route_name_list = route_name_list
	@muti_id = true
	base_init(id, name, 0, father_node_name, ROUTE_TYPE, desc)
    end

    # 初始化 info type 的 node
    def info_init(id, name, father_node_name, desc = nil)
	@muti_id = true
	base_init(id, name, 0, father_node_name, INFO_TYPE, desc)
    end

    # 初始化 route 的 children node
    def route_children_init route_base, name
	@muti_id = true
	check_init(route_base.id, name, route_base.name, "route children")
    end

    # 是否可以存在多个相同的ID
    def muti_id
	@muti_id || false
    end

    def route_name_list
	@route_name_list || []
    end

    def type
	case @node_type
	when CHECK_TYPE
		return 'check'
	when EXPLOIT_TYPE
		return 'exploit'
	when ROUTE_TYPE
		return 'route'
	when INFO_TYPE
		return 'info'
	else
		return 'unknow'
	end
    end

    # 检测是否有漏洞, 用于exploit type
    # 返回 [true/false , args1, args2, ....]
    def exploit_func host
    	exploit_failed 
    end

    # 检测是否符合某条标准, 用于check type
    # 返回 true/false
    def check_func host
        return true
    end

    # 检测是否符合某条标准, 用于route type
    # 返回 base_name
    def route_func host
        return nil
    end

    def info_func host 
        return nil
    end

    def exploit_success *args
	args.unshift true
    end

    def exploit_failed *args
	args.unshift false
    end

    def get_exploit_return_status return_list
	return return_list[0]
    end

    def get_exploit_msg_list return_list
	return return_list[2...(return_list.size + 1)]
    end

    def get_exploit_msg_string return_list
	return return_list[1]
    end

    def set_exam_params exm, return_list
	get_exploit_msg_list(return_list).each_with_index do |v, p|
		next if v.blank? 
		p = p + 1
		v = v.to_json
		exm.instance_eval("exm.p#{p} = #{v}") if exm.respond_to?("p#{p}")
	end
    end

    def check host
	check_func host
    end

    def route host
	route_func host
    end

    def info host
	info_func host
    end

    def exploit host
	# 检测此机器是否被测试过
        if host.is_tested_by_exploit(id)
            exploit_logger.error("ADONIS::EXPLOIT::Base.exploit, #{id}: already tested #{id}: #{host.ip}")
            return false
        end

        msg = "----#{id}: start explioit #{Time.now}--"

	# 调用渗透方法测试
        return_list = exploit_func host
	exploit_status = get_exploit_return_status return_list
	log_msg = get_exploit_msg_string return_list

	case exploit_status
        when true
            msg += log_msg
            exploit_logger.info("ADONIS::EXPLOIT::Base.exploit, #{id}: exploit success #{id}: #{host.ip} #{log_msg}")
            host.is_vuln = Time.now.to_i
            host.add_exploit_module id

            # 创建Exm
            exm = ::ADONIS::MODEL::Exm.new
	    exms_hash = {:module_id => id.to_i, :host_id => host.id}
	    get_exploit_msg_list(return_list).each_with_index do |v, p|
		p = p + 1
		v = v.to_json
		exms_hash.update({"p#{p}".to_sym => v}) if exm.respond_to?("p#{p}")
	    end
	
	    exms_list = ::ADONIS::MODEL::Exm.where(exms_hash)
            if exms_list.size == 0  
                exm.module_id = id.to_i
                exm.host_id = host.id
                set_exam_params exm, return_list
		exm.active_time = Time.now.to_i
                exm.save
            else
		exms = exms_list.first
		exm.active_time = Time.now.to_i
                exm.save
            end
        else
            msg += "failed: #{log_msg}"
            exploit_logger.info("ADONIS::EXPLOIT::Base.exploit, #{id}: exploit notsucc #{id}: #{host.ip} #{log_msg}")
        end

        msg += "--#{id} exploit end #{Time.now}----"
        host.add_tested_exploit_module(id)

        if host.history.nil?
            host.history = msg
        else
            host.history = host.history + msg
        end

        host.save

	return exploit_status
    end

end

class RootBase < Base
    def init
	check_init(0, 'root', nil, 'root')
    end
end

end
end

